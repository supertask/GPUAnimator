// Each #kernel tells which function to compile; you can have many kernels
#pragma enable_d3d11_debug_symbols
#pragma kernel UpdateAnimation
#pragma kernel TransitionAnimation

Texture2D<float3> PositionAnimTexture;
Texture2D<float3> PositionAnimTexture_Next;
Texture2D<float3> NormalAnimTexture;
Texture2D<float3> NormalAnimTexture_Next;

float _NormalizedAnimTime;
float _NormalizedAnimTime_Next;

RWStructuredBuffer<float3> PositionBuffer;
RWStructuredBuffer<float3> NormalBuffer;

float4 _TexelSize;
float4 _TexelSize_Next;

float _TransitionTime;

[numthreads(1024, 1, 1)]
void UpdateAnimation(uint id : SV_DispatchThreadID)
{
	uint2 texPosition = uint2(id, (uint)(_NormalizedAnimTime * _TexelSize.w) );
	if (texPosition.x >= _TexelSize.z || texPosition.y >= _TexelSize.w) return;

	float3 pos = PositionAnimTexture[texPosition];
	float3 normal = NormalAnimTexture[texPosition];

	PositionBuffer[id] = pos;
	NormalBuffer[id] = normal;
}

[numthreads(1024, 1, 1)]
void TransitionAnimation(uint id : SV_DispatchThreadID)
{
	uint2 texPosition = uint2(id, (uint)(_NormalizedAnimTime * _TexelSize.w) );
	if (texPosition.x >= _TexelSize.z || texPosition.y >= _TexelSize.w) return;

	uint2 texPositionNext = uint2(id, (uint)(_NormalizedAnimTime_Next * _TexelSize_Next.w) );
	if (texPositionNext.x >= _TexelSize_Next.z || texPositionNext.y >= _TexelSize_Next.w) return;

	float3 pos = PositionAnimTexture[texPosition];
	float3 normal = NormalAnimTexture[texPosition];

	float3 next_pos = PositionAnimTexture_Next[texPositionNext];
	float3 next_normal = NormalAnimTexture_Next[texPositionNext];

	PositionBuffer[id] = lerp(pos, next_pos, _TransitionTime);
	NormalBuffer[id] = lerp(normal, next_normal, _TransitionTime);

	//PositionBuffer[id] = next_pos;
	//NormalBuffer[id] = next_normal;



	//BUG: Walk=falseの時next_posは何もない状態になっている
}
